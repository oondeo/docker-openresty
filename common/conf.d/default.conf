include /etc/nginx/conection_params;
include /etc/nginx/cache_params;
include /etc/nginx/gzip_params;

include naxsi/naxsi_core.rules;


# If we receive X-Forwarded-Proto, pass it through; otherwise, pass along the
# scheme used to connect to this server
#map $http_x_forwarded_proto $proxy_x_forwarded_proto {
#  default $http_x_forwarded_proto;
#  ''      $scheme;
#}

# If we receive Upgrade, set Connection to "upgrade"; otherwise, delete any
# Connection header that may have been passed to this server
#map $http_upgrade $proxy_connection {
#  default upgrade;
#  '' close;
#}

server {

  listen 8081;
  server_name {{DOMAIN_DEV}};
  
  access_log /var/log/nginx/access.log main;
  location / {

    proxy_pass http://127.0.0.1:8080;
    
    proxy_set_header Host "{{DOMAIN_PROD}}";  
    proxy_set_header Accept-Encoding "";
    
    proxy_set_header        X-Forwarded-Host  "{{DOMAIN_PROD}}";
    
    proxy_redirect                  http://{{DOMAIN_PROD}}/ /;
    proxy_redirect                  http://{{DOMAIN_PROD}}:8080/ /;
  

    proxy_cookie_domain             '{{DOMAIN_PROD}}' '{{DOMAIN_DEV}}';
      sub_filter_once off;
            sub_filter_types *;                                                         
            sub_filter "{{DOMAIN_PROD}}" "{{DOMAIN_DEV}}" ;
        
  
   # replace request
   access_by_lua_block{

if ngx.req.get_method() == "POST" then   
    ngx.req.read_body()
    local data = ngx.req.get_body_data() 
    if data then
      local newargs, n, err = ngx.re.gsub(data, "{{DOMAIN_DEV}}", "{{DOMAIN_PROD}}") 
      ngx.req.set_body_data(newargs)
    end
    local file = ngx.req.get_body_file()
    if file then                                                                                         
      local newargs, n, err = ngx.re.gsub(file, "{{DOMAIN_DEV}}", "{{DOMAIN_PROD}}")
      ngx.req.set_body_data(newargs)
    end 
else
  local args = ngx.req.get_uri_args()
  local newargs = {}
  for key, val in pairs(args) do
    if type(val) == "string" then
      local newval, n , err =  ngx.re.gsub(val, "{{DOMAIN_DEV}}", "{{DOMAIN_PROD}}")
      newargs[key]=newval
    else
      newargs[key]=val
    end
  end
        ngx.req.set_uri_args(newargs)
end

    }

#   #rewrite reponse
#     body_filter_by_lua_block{
#local resp_body = string.sub(ngx.arg[1], 1, 1000)  -- arg[1] contains a chunk of response content
#ngx.ctx.buffered = string.sub((ngx.ctx.buffered or "") .. resp_body, 1, 1000)
#if ngx.arg[2] and ngx.req.get_method() == "POST" then  -- arg[2] is true if this is the last chunk
#  ngx.log(ngx.STDERR,ngx.ctx.buffered)
#end  
#   }

  }

}

server {
    listen 8080;
    server_name {{DOMAIN_PROD}};

    access_log off;

    include server_cache_params;

    # this prevents hidden files (beginning with a period) from being served
    location ~ /\.          { access_log off; log_not_found off; deny all; }

        root {{HOME}};
        index index.html index.htm index.php;

        location / {


            try_files $uri $uri/ /index.php$is_args$args;;


        }


        location ~* .(ogg|ogv|svg|svgz|eot|otf|woff|mp4|ttf|css|rss|atom|js|jpg|jpeg|gif|png|ico|zip|tgz|gz|rar|bz2|doc|xls|exe|ppt|tar|mid|midi|wav|bmp|rtf)$ {
                expires max;
                log_not_found off;
                access_log off;
                aio threads=default;
        }
        location = /robots.txt {
                access_log off;
                log_not_found off;
        }
        location = /favicon.ico {
          expires max;
          log_not_found off;
          access_log off;
        }


        location ~ \.(hh|php)$ {
            try_files $uri =404;

            ## Naxsi rules
            LearningMode;
            SecRulesEnabled;
            #SecRulesDisabled;
            DeniedUrl "/RequestDenied";

            ## check rules
            CheckRule "$SQL >= 10" BLOCK;
            CheckRule "$RFI >= 8" BLOCK;
            CheckRule "$TRAVERSAL >= 4" BLOCK;
            CheckRule "$EVADE >= 4" BLOCK;
            CheckRule "$XSS >= 8" BLOCK;
            include naxsi/rules/wordpress.rules;             
            include naxsi/naxsi_core.rules;

            #Bypass cache if no-cache cookie is set
            if ($http_cookie ~* "_mcnc") {
                    set $no_cache "1";
            }
            # Drop no cache cookie if need be
            # (for some reason, add_header fails if included in prior if-block)
            if ($no_cache = "1") {
                add_header Set-Cookie "_mcnc=1; Max-Age=2; Path=/";
                add_header X-Microcachable "0";
            }

            include fastcgi_cache_params;

            add_header X-Fastcgi-Cache $upstream_cache_status;
            fastcgi_pass_header Set-Cookie;
            fastcgi_pass_header Cookie;
            fastcgi_pass_header 'Accept-Encoding ""';
            fastcgi_ignore_headers Cache-Control Expires Set-Cookie;

            fastcgi_index index.php;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
            fastcgi_param  HTTPS $fe_https;

            include fastcgi_params;

            fastcgi_pass 127.0.0.1:9000;
            #fastcgi_pass  unix:/var/run/php-fpm.sock;
        }

}

server {
    listen       8080 default_server;
    server_name  _;
    return       301 http://{{DOMAIN_DEV}};
}

server {
    listen       8081 default_server;
    server_name  _;
    return       301 http://{{DOMAIN_PROD}};
}